/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.om.inctc

import com.github.om.inctc.bench.StlcGenerator
import com.github.om.inctc.bench.Timer
import com.github.om.inctc.lang.stlc.*

/**
 * Some notes: 5k decls per file cause the parser to stack overflow.
 * 2k decls per file, 5 files -- parsing needs 1.5-2.3s (after JIT warms up: .9s) and tc 1.2s LOL
 * (Though this is partly because the language permits recursive definitions across module boundaries --
 * this is something GHC doesn't allow (https://wiki.haskell.org/Mutually_recursive_modules).
 * Essentially this makes the whole module system a giant single file, which is bad. Let me trydisabling that...)
 */

fun bench(files: List<Pair<ModuleName, String>>, printStat: Boolean = false) {
    val tm = Timer()
    val parsedAgain = tm.timed("parse") {
        files.map {
            requireNotNull(StlcParser.file(it.first).run(it.second))
        }
    }
    val rCtx = tm.timed("rCtx") { ResolutionContext(parsedAgain) }
    tm.timed("findUndef") { rCtx.findUndefinedUses().firstOrNull() }
    val tCtx = TypeContext()
    tm.timed("tc") { tCtx.populateAndInferModules(rCtx) }
    if (printStat) {
        tm.printStat()
    }
}

fun main() {
    val tm = Timer()
    val modules = tm.timed("poet") {
        val g = StlcGenerator(500, 10000)
        val totalSteps = tm.timed("run") { g.run() }
        println("Total steps: $totalSteps")
        tm.timed("build") { g.build() }
    }
    println("N modules: ${modules.size}")
    val files = tm.timed("ppr") {
        modules.map {
            it.name to PprState.ppr(it)
        }
    }

    /*
    repeat(10) {
        println("$it run")
        bench(files)
    }

     */

    bench(files, true)
}
