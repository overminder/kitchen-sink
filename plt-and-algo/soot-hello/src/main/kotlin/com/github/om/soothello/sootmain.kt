/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.om.soothello

import soot.G
import soot.Scene
import soot.SootClass
import soot.jimple.JimpleBody
import soot.options.Options
import java.io.File

fun setupSoot(className: String, extraCp: List<File>) {
    G.reset()
    // phantom refs: treat unable-to-be-resolved classes as black box
    Options.v().set_allow_phantom_refs(true)
    // TODO: Find correct jdk classpath
    val javacp = Scene.defaultJavaClassPath()
    val cps = (listOf(javacp) + extraCp).joinToString(":")

    Options.v().set_soot_classpath(cps)

    loadWithSupport(className)
}

fun loadWithSupport(className: String): SootClass {
    // Load custom class and add to analysis set
    val sc = Scene.v().loadClassAndSupport(className)

    assert(!sc.isPhantom)
    sc.setApplicationClass()

    // Load JDK classes
    // LoadNecessary before loadClassAndSupport: need to manually set deps's level
    // After: recursive load when necessary.
    // (Can't call this multiple times)
    // Scene.v().loadNecessaryClasses()
    return Scene.v().getSootClass(className)
}

fun relToHome(x: String): File {
    return File(System.getProperty("user.home")) / x
}

object Chrysaor {
    val rootDir = relToHome("src/chrysaor")

    val projects = listOf(
        "data",
        "data-jackson",
        "data-protobuf",
        "data-restli",
        "generator-data",
        "generator-restli-request",
        "restli-client",
        "restli-client-r2",
        "restli-client-req-resp",
        "restli-common",
        "restli-int-test",
        "restli-model",
    )

    fun findExtraCps(): List<File> {
        val out = mutableListOf<File>()
        val buildDir = File(rootDir, "build")
        for (p in projects) {
            val pBuildDir = buildDir / p
            if (pBuildDir.isDirectory) {
                val pClasspath = pBuildDir / "classes" / "java" / "main"
                assert(pClasspath.isDirectory)
                out += pClasspath
            }
        }
        return out
    }

    fun main() {
        val clsName = "com.linkedin.data.lite.Optional"
        val methodName = "get"
        setupSoot(clsName, findExtraCps())
        val mainClass = Scene.v().getSootClass(clsName)
        println(mainClass.methods)
        println(loadWithSupport("com.linkedin.data.lite.DataTemplate").methods)
        /*
        val sm = mainClass.getMethodByName(methodName)
        val body = sm.retrieveActiveBody() as JimpleBody
         */
    }
}

internal operator fun File.div(s: String): File {
    return File(this, s)
}

fun fizzBuzzMain() {
    val clsName = "FizzBuzz"
    val methodName = "printFizzBuzz"
    setupSoot(clsName, listOf(relToHome("ref/SootTutorial/demo/HelloSoot")))
    // Retrieve printFizzBuzz's body
    val mainClass = Scene.v().getSootClass(clsName)
    val sm = mainClass.getMethodByName(methodName)
    val body = sm.retrieveActiveBody() as JimpleBody

    println(body)
}

fun main() {
    Chrysaor.main()
    // fizzBuzzMain()
}